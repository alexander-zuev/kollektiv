from datetime import UTC, datetime
from enum import Enum
from typing import Any, ClassVar, List, Optional, Union
from uuid import UUID, uuid4

from pydantic import BaseModel, Field

from src.models.base_models import BaseDbModel


# Base LLM models
class StandardEventType(str, Enum):
    """Standardized event types mapped from Anthropic events."""

    # Regular message events
    MESSAGE_START = "message_start"  # Initial message event
    TEXT_TOKEN = "text_token"  # Content block delta with text
    MESSAGE_STOP = "message_stop"  # Message completion

    # Tool-related events
    TOOL_START = "tool_start"  # Tool use content block
    TOOL_END = "tool_end"  # Tool execution completion
    TOOL_RESULT = "tool_result"  # Tool execution result

    # Error events
    ERROR = "error"  # Any error during processing


class StandardEvent(BaseModel):
    """Standard event structure for internal use."""

    event_type: StandardEventType
    content: str | dict[str, Any] = Field(description="Event content - text for tokens, structured data for tools")
    tool_info: dict[str, Any] | None = Field(None, description="Tool-specific information when relevant")


class Role(str, Enum):
    """Roles in the conversation."""

    ASSISTANT = "assistant"
    USER = "user"


class ContentBlockType(str, Enum):
    """Types of content blocks in a conversation that are used by Anthropic."""

    TEXT = "text"
    IMAGE = "image"
    TOOL_USE = "tool_use"
    TOOL_RESULT = "tool_result"
    DOCUMENT = "document"


class ContentBlock(BaseModel):
    """Base class for all content blocks"""

    block_type: ContentBlockType = Field(..., description="Type of the content block", alias="type")
    text: str | None = Field(None, description="Text content if type is 'text'")

    class Config:
        allow_population_by_field_name = True


class TextBlock(ContentBlock):
    """Simple text content"""

    block_type: ContentBlockType = Field(ContentBlockType.TEXT, description="Type of the content block", alias="type")
    text: str


class ToolUseBlock(ContentBlock):
    """Tool usage by assistant"""

    block_type: ContentBlockType = Field(
        ContentBlockType.TOOL_USE, description="Type of the content block", alias="type"
    )
    name: str = Field(..., description="Name of the tool")
    input: dict = Field(..., description="Input to the tool")
    id: str = Field(..., description="ID of the tool use")


class ToolResultBlock(ContentBlock):
    """Tool result from assistant"""

    block_type: ContentBlockType = Field(
        ContentBlockType.TOOL_RESULT, description="Type of the content block", alias="type"
    )
    tool_use_id: str = Field(..., description="ID of the tool use")
    content: str | dict | None = Field(None, description="Result returned from the tool")
    is_error: bool | None = Field(None, description="Error returned from the tool")


class MessageContent(BaseModel):
    """Content of a conversation message."""

    blocks: List[Union[TextBlock, ToolUseBlock, ToolResultBlock]] = Field(
        ...,
        description="List of content blocks"
    )

    @classmethod
    def from_str(cls, text: str) -> "MessageContent":
        """Create MessageContent from a string."""
        return cls(blocks=[TextBlock(text=text)])

    def to_anthropic(self) -> list[dict[str, Any]]:
        """Convert to Anthropic API format."""
        return [block.model_dump(by_alias=True) for block in self.blocks]


class ConversationMessage(BaseDbModel):
    """A message in a conversation between a user and an LLM."""

    message_id: UUID = Field(default_factory=uuid4, description="UUID of a message generated by the application.")
    conversation_id: UUID | None = Field(
        None,
        description="FK reference to a conversation. Can be empty? How can it not be empty? We should create conversation before saving a message?",
    )
    role: Role = Field(..., description="Role of the message sender")
    content: MessageContent = Field(..., description="Structured content of the message")

    _db_config: ClassVar[dict] = {"schema": "chat", "table": "conversation_messages", "primary_key": "message_id"}

    def to_anthropic(self) -> dict:
        """Convert to Anthropic API format"""
        return {"role": self.role.value, "content": self.content.to_anthropic()}


class ConversationHistory(BaseModel):
    """A list of messages for a conversation"""

    conversation_id: UUID = Field(default_factory=uuid4, description="FK reference to UUID of the conversation")
    messages: list[ConversationMessage] = Field(
        default_factory=list, description="List of messages in the conversation"
    )
    token_count: int = Field(default=0, description="Total token count for the conversation, initially 0")
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC), description="Creation timestamp")
    updated_at: datetime | None = Field(default=None, description="Last updated timestamp")

    def to_anthropic_messages(self) -> list[dict]:
        """Convert entire history to Anthropic format"""
        return [msg.to_anthropic() for msg in self.messages]

    def append(self, role: Role | str, content: str | MessageContent) -> None:
        """
        Append a new message to the conversation history.

        Args:
            role: The role of the message sender (user or assistant)
            content: The content of the message, either as string or MessageContent
        """
        if isinstance(role, str):
            role = Role(role)

        if isinstance(content, str):
            content = MessageContent.from_str(content)
        elif not isinstance(content, MessageContent):
            raise ValueError("Content must be either string or MessageContent")

        message = ConversationMessage(
            conversation_id=self.conversation_id,
            role=role,
            content=content
        )
        self.messages.append(message)
        self.updated_at = datetime.now(UTC)


# TODO: to refactor
# class ConversationMessage:
#     """
#     Represent a conversation message with an ID, role, and content.

#     Args:
#         role (str): The role of the message sender (e.g., 'user', 'system').
#         content (Union[str, list[MessageContent]]): The content of the message.
#     """

#     def __init__(self, role: str, content: str | list[MessageContent]) -> None:
#         self.id: str = str(uuid.uuid4())
#         self.role: str = role
#         self.content: str | list[MessageContent] = content

#     def to_dict(self, include_id: bool = False) -> dict[str, Any]:
#         """Convert the message object to a dictionary."""
#         message_dict: dict[str, Any] = {"role": self.role, "content": self.content}
#         if include_id:
#             message_dict["id"] = self.id
#         return message_dict


class ConversationRecency(str, Enum):
    """A domain model for a group of conversations ordered by time."""

    RECENT = "recent"
    LAST_THIRTY_DAYS = "last_thirty_days"
    OLDER = "older"


class Conversation(BaseDbModel):
    """Domain model for a conversation."""

    conversation_id: UUID = Field(default_factory=uuid4, description="UUID of the conversation")
    user_id: UUID = Field(..., description="FK reference to UUID of the user")
    title: str = Field(..., description="Title of the conversation")
    data_sources: list[UUID] = Field(
        default=...,
        description="FK references to UUIDs of the data sources last active for the conversation",
    )

    _db_config: ClassVar[dict] = {"schema": "chat", "table": "conversations", "primary_key": "conversation_id"}


class Conversations(BaseModel):
    """A domain model for a list of conversations that a user has."""

    user_id: UUID = Field(..., description="FK reference to UUID of the user")
