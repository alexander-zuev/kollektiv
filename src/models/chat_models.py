from datetime import UTC, datetime
from enum import Enum
from typing import Any, ClassVar, Union
from uuid import UUID, uuid4

from pydantic import BaseModel, ConfigDict, Field

from src.models.base_models import BaseDbModel


# Base LLM models
class StandardEventType(str, Enum):
    """Standardized event types mapped from Anthropic events."""

    # Regular message events
    MESSAGE_START = "message_start"
    TEXT_TOKEN = "text_event"  # maps from text event
    MESSAGE_STOP = "message_stop"  # maps from message_stop

    # Tool-related events
    TOOL_START = "tool_start"  # maps from content_block_start with tool_use
    TOOL_RESULT = "tool_result"  # when tool execution completes

    # Final message
    FULL_MESSAGE = "full_message"

    # Error events
    ERROR = "error"  # any error during processing


class StandardEvent(BaseModel):
    """Standard event structure for internal use."""

    event_type: StandardEventType
    content: Union[str, dict, "MessageContent"] = Field(
        description="Event content - text tokens, tool data, or full message content"
    )
    tool_info: dict[str, Any] | None = Field(None, description="Tool-specific information when relevant")


class Role(str, Enum):
    """Roles in the conversation."""

    ASSISTANT = "assistant"
    USER = "user"


class ContentBlockType(str, Enum):
    """Types of content blocks in a conversation that are used by Anthropic."""

    TEXT = "text"
    IMAGE = "image"
    TOOL_USE = "tool_use"
    TOOL_RESULT = "tool_result"
    DOCUMENT = "document"


class ContentBlock(BaseModel):
    """Base class for all content blocks"""

    block_type: ContentBlockType = Field(..., description="Type of the content block", alias="type")

    model_config = ConfigDict({"populate_by_name": True, "from_attributes": True})


class TextBlock(ContentBlock):
    """Simple text content"""

    block_type: ContentBlockType = Field(ContentBlockType.TEXT, description="Type of the content block", alias="type")
    text: str = Field(..., description="Text content of the block")


class ToolUseBlock(ContentBlock):
    """Tool usage by assistant"""

    block_type: ContentBlockType = Field(
        ContentBlockType.TOOL_USE, description="Type of the content block", alias="type"
    )
    tool_name: str = Field(..., description="Name of the tool", alias="name")
    tool_input: dict = Field(..., description="Input to the tool", alias="input")
    tool_use_id: str = Field(..., description="ID of the tool use", alias="id")


class ToolResultBlock(ContentBlock):
    """Tool result from assistant"""

    block_type: ContentBlockType = Field(
        ContentBlockType.TOOL_RESULT, description="Type of the content block", alias="type"
    )
    tool_use_id: str = Field(..., description="ID of the tool use")
    content: str | dict | None = Field(None, description="Result returned from the tool")
    is_error: bool | None = Field(None, description="Error returned from the tool")


class ToolUseInput(BaseModel):
    """Tool use input"""

    tool_name: str = Field(..., description="Name of the tool corresponding to the tool schema")
    tool_input: dict[str, Any] = Field(..., description="Input to the tool according to schema")
    tool_use_id: str = Field(..., description="ID of the tool use")


class MessageContent(BaseModel):
    """Content that can be either string or structured blocks"""

    blocks: list[ContentBlock]

    @classmethod
    def from_str(cls, text: str) -> "MessageContent":
        """Create MessageContent from string"""
        return cls(blocks=[TextBlock(text=text)])

    def to_anthropic(self) -> str | list[dict]:
        """Convert to Anthropic API format"""
        if len(self.blocks) == 1 and isinstance(self.blocks[0], TextBlock):
            return self.blocks[0].text
        return [block.dict(exclude_none=True) for block in self.blocks]


class ConversationMessage(BaseDbModel):
    """A message in a conversation between a user and an LLM."""

    message_id: UUID = Field(default_factory=uuid4, description="UUID of a message generated by the application.")
    conversation_id: UUID | None = Field(
        None,
        description="FK reference to a conversation. Can be empty? How can it not be empty? We should create conversation before saving a message?",
    )
    role: Role = Field(..., description="Role of the message sender")
    content: MessageContent = Field(..., description="Structured content of the message")

    _db_config: ClassVar[dict] = {"schema": "chat", "table": "conversation_messages", "primary_key": "message_id"}

    def to_anthropic(self) -> dict:
        """Convert to Anthropic API format"""
        return {"role": self.role.value, "content": self.content.to_anthropic()}


class ConversationHistory(BaseModel):
    """A list of messages for a conversation"""

    conversation_id: UUID = Field(default_factory=uuid4, description="FK reference to UUID of the conversation")
    messages: list[ConversationMessage] = Field(
        default_factory=list, description="List of messages in the conversation"
    )
    token_count: int = Field(default=0, description="Total token count for the conversation, initially 0")
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC), description="Creation timestamp")
    updated_at: datetime | None = Field(default=None, description="Last updated timestamp")

    def to_anthropic_messages(self) -> list[dict]:
        """Convert entire history to Anthropic format"""
        return [msg.to_anthropic() for msg in self.messages]


class ConversationRecency(str, Enum):
    """A domain model for a group of conversations ordered by time."""

    RECENT = "recent"
    LAST_THIRTY_DAYS = "last_thirty_days"
    OLDER = "older"


class Conversation(BaseDbModel):
    """Domain model for a conversation in chat.."""

    conversation_id: UUID = Field(default_factory=uuid4, description="UUID of the conversation")
    user_id: UUID = Field(..., description="FK reference to UUID of the user")
    title: str = Field(..., description="Title of the conversation")
    messages: list[ConversationMessage] = Field(
        default_factory=list, description="List of messages in the conversation"
    )
    data_sources: list[UUID] = Field(
        default=...,
        description="FK references to UUIDs of the data sources last active for the conversation",
    )

    _db_config: ClassVar[dict] = {"schema": "chat", "table": "conversations", "primary_key": "conversation_id"}


class Conversations(BaseModel):
    """A domain model for a list of conversations that a user has."""

    user_id: UUID = Field(..., description="FK reference to UUID of the user")
