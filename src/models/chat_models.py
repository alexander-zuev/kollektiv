from __future__ import annotations

import json
from datetime import UTC, datetime
from enum import Enum
from typing import ClassVar
from uuid import UUID, uuid4

from pydantic import BaseModel, ConfigDict, Field

from src.infrastructure.common.logger import get_logger
from src.models.base_models import BaseDbModel

logger = get_logger()


# Base LLM models
class StandardEventType(str, Enum):
    """Standardized event types mapped from Anthropic events."""

    # Regular message events
    MESSAGE_START = "message_start"
    TEXT_TOKEN = "text_event"  # maps from text event
    MESSAGE_STOP = "message_stop"  # maps from message_stop

    # Tool-related events
    TOOL_START = "tool_start"  # maps from content_block_start with tool_use
    TOOL_RESULT = "tool_result"  # when tool execution completes

    # Final message
    FULL_MESSAGE = "full_message"

    # Error events
    ERROR = "error"  # any error during processing


class StandardEvent(BaseModel):
    """Standard event structure for internal use."""

    event_type: StandardEventType = Field(..., description="Type of the event")
    content: list[ContentBlock] | str = Field(description="Content of the event, list of blocks or text")
    is_error: bool = Field(default=False, description="Whether the event is an error")


class Role(str, Enum):
    """Roles in the conversation."""

    ASSISTANT = "assistant"
    USER = "user"


class ContentBlockType(str, Enum):
    """Types of content blocks in a conversation that are used by Anthropic."""

    TEXT = "text"
    IMAGE = "image"
    TOOL_USE = "tool_use"
    TOOL_RESULT = "tool_result"
    DOCUMENT = "document"


class ContentBlock(BaseModel):
    """Base class for all content blocks"""

    block_type: ContentBlockType = Field(..., description="Type of the content block", alias="type")

    model_config = ConfigDict({"populate_by_name": True, "from_attributes": True})

    @classmethod
    def create_blocks(cls, data: list[dict]) -> list[ContentBlock]:
        """
        Factory method to create a list of ContentBlock objects from a list of dictionaries.

        Args:
            data: A list of dictionaries, where each dictionary represents a ContentBlock.
                  The dictionary should have a "type" key to indicate the ContentBlockType,
                  and other keys corresponding to the attributes of the specific ContentBlock type.

        Returns:
            A list of ContentBlock objects.
        """
        blocks = []
        for item in data:
            block_type = item.get("type")
            if block_type == ContentBlockType.TEXT:
                blocks.append(TextBlock.model_validate(item))
            elif block_type == ContentBlockType.TOOL_USE:
                blocks.append(ToolUseBlock.model_validate(item))
            elif block_type == ContentBlockType.TOOL_RESULT:
                blocks.append(ToolResultBlock.model_validate(item))
            else:
                logger.warning(f"Unknown block type: {block_type}")
            # Add other block types as needed
        return blocks


class TextBlock(ContentBlock):
    """Simple text content"""

    block_type: ContentBlockType = Field(ContentBlockType.TEXT, description="Type of the content block", alias="type")
    text: str = Field(..., description="Text content of the block")


class ToolUseBlock(ContentBlock):
    """Tool usage by assistant"""

    block_type: ContentBlockType = Field(
        ContentBlockType.TOOL_USE, description="Type of the content block", alias="type"
    )
    tool_name: str = Field(..., description="Name of the tool", alias="name")
    tool_input: dict = Field(..., description="Input to the tool", alias="input")
    tool_use_id: str = Field(..., description="ID of the tool use", alias="id")


class ToolResultBlock(ContentBlock):
    """Tool result from assistant"""

    block_type: ContentBlockType = Field(
        ContentBlockType.TOOL_RESULT, description="Type of the content block", alias="type"
    )
    tool_use_id: str = Field(..., description="ID of the tool use")
    content: str | dict | None = Field(None, description="Result returned from the tool")
    is_error: bool | None = Field(None, description="Error returned from the tool")


class ConversationMessage(BaseDbModel):
    """A message in a conversation between a user and an LLM."""

    message_id: UUID = Field(default_factory=uuid4, description="UUID of a message generated by the application.")
    conversation_id: UUID | None = Field(None, description="FK reference to a conversation.")
    role: Role = Field(..., description="Role of the message sender")
    content: list[ContentBlock] = Field(..., description="list of content blocks")

    _db_config: ClassVar[dict] = {"schema": "chat", "table": "conversation_messages", "primary_key": "message_id"}

    def to_anthropic(self) -> dict:
        """Convert to Anthropic API format"""
        content = []
        for block in self.content:
            if block.block_type == ContentBlockType.TEXT:
                content.append({"type": "text", "text": block.text})
            elif block.block_type == ContentBlockType.TOOL_USE:
                content.append(
                    {
                        "type": "tool_use",
                        "id": block.tool_use_id,
                        "name": block.tool_name,
                        "input": block.tool_input,
                    }
                )
            elif block.block_type == ContentBlockType.TOOL_RESULT:
                content_value = block.content
                if isinstance(content_value, dict):
                    content_value = json.dumps(content_value)

                content.append(
                    {
                        "type": "tool_result",
                        "tool_use_id": block.tool_use_id,
                        "content": content_value,
                        "is_error": block.is_error,
                    }
                )
            # Add other block types as needed

        return {"role": self.role.value, "content": content}


class ConversationHistory(BaseModel):
    """A list of messages for a conversation"""

    conversation_id: UUID = Field(default_factory=uuid4, description="FK reference to UUID of the conversation")
    messages: list[ConversationMessage] = Field(
        default_factory=list, description="List of messages in the conversation"
    )
    token_count: int = Field(default=0, description="Total token count for the conversation, initially 0")
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC), description="Creation timestamp")
    updated_at: datetime | None = Field(default=None, description="Last updated timestamp")

    def to_anthropic_messages(self) -> list[dict]:
        """Convert entire history to Anthropic format"""
        return [msg.to_anthropic() for msg in self.messages]


class ConversationRecency(str, Enum):
    """A domain model for a group of conversations ordered by time."""

    RECENT = "recent"
    LAST_THIRTY_DAYS = "last_thirty_days"
    OLDER = "older"


class Conversation(BaseDbModel):
    """Domain model for a conversation in chat.."""

    conversation_id: UUID = Field(default_factory=uuid4, description="UUID of the conversation")
    user_id: UUID = Field(..., description="FK reference to UUID of the user")
    title: str = Field(..., description="Title of the conversation")
    messages: list[ConversationMessage] = Field(
        default_factory=list, description="List of messages in the conversation"
    )
    data_sources: list[UUID] = Field(
        default=...,
        description="FK references to UUIDs of the data sources last active for the conversation",
    )

    _db_config: ClassVar[dict] = {"schema": "chat", "table": "conversations", "primary_key": "conversation_id"}
