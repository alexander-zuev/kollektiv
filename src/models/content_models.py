from __future__ import annotations

from enum import Enum
from typing import Any, ClassVar
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, PrivateAttr

from src.models.base_models import SupabaseModel


class DataSourceType(str, Enum):
    """Enum of all different data sources supported by Kollektiv."""

    WEB = "web"
    GITHUB = "github"
    JIRA = "jira"
    CONFLUENCE = "confluence"


class SourceStatus(str, Enum):
    """Model of Source Status."""

    PENDING = "pending"  # right after creation
    CRAWLING = "crawling"  # after crawling started
    CRAWLED = "crawled"  # after loading is complete
    PROCESSING = "processing"  # during chunking and embedding
    ADDING_SUMMARY = "adding_summary"  # during adding summaries
    COMPLETED = "completed"  # after processing is complete
    FAILED = "failed"  # if addition failed


class DataSource(SupabaseModel):
    """Base model for all raw data sources loaded into the system."""

    _db_config: ClassVar[dict] = {"schema": "content", "table": "data_sources", "primary_key": "source_id"}

    # User-related
    user_id: UUID = Field(..., description="User id, FK, provided by Supabase base after auth.")

    source_id: UUID = Field(default_factory=uuid4)
    source_type: DataSourceType = Field(
        ..., description="Type of the data source corresponding to supported data source types"
    )
    status: SourceStatus = Field(..., description="Status of the content source in the system.")
    metadata: dict[str, Any] = Field(
        default_factory=dict, description="Source-specific configuration and metadata. Schema depends on source_type"
    )
    request_id: UUID = Field(..., description="Request id of the user request to add content")
    job_id: UUID | None = Field(default=None, description="UUID of the job in the system.")

    error: str | None = Field(default=None, description="Error message, null if no error")

    # Define protected fields that cannot be updated
    _protected_fields: set[str] = PrivateAttr(default={"source_id", "source_type", "created_at"})


class SourceSummary(SupabaseModel):
    """A summary of a source document generated by an LLM."""

    summary_id: UUID = Field(default_factory=uuid4, description="Unique identifier for the summary")
    source_id: UUID = Field(..., description="ID of the source this summary belongs to")
    summary: str = Field(..., description="Summary of the source document generated by the LLM")
    keywords: list[str] = Field(..., description="List of keywords or key topics generated by the LLM")

    _db_config: ClassVar[dict] = {"schema": "chat", "table": "source_summaries", "primary_key": "summary_id"}

    class Config:
        """Pydantic model configuration."""

        from_attributes = True


# Document models
class Document(SupabaseModel):
    """Represents a single piece of content (i.e. a page) from a source."""

    document_id: UUID = Field(default_factory=uuid4, description="Unique identifier for the document")
    source_id: UUID = Field(
        ...,  # Can't be required but should be here somehow
        description="ID of the source this document belongs to",
    )
    content: str = Field(
        ...,  # Required
        description="Raw content of the document in markdown format",
    )
    metadata: dict[str, Any] = Field(
        default_factory=dict, description="Flexible metadata storage for document-specific information"
    )
    _db_config: ClassVar[dict] = {"schema": "content", "table": "documents", "primary_key": "document_id"}

    class Config:
        """Pydantic model configuration."""

        from_attributes = True


class DocumentMetadata(BaseModel):
    """
    Flexible metadata container for document-specific information.

    Accepts any number of keyword arguments which become metadata fields.
    Common fields might include:
    - description: Document description or summary
    - keywords: List of keywords or tags
    - author: Document author
    - last_modified: Last modification timestamp
    - language: Document language
    """

    def __init__(self, **kwargs: Any) -> None:
        """Initialize metadata with arbitrary keyword arguments."""
        super().__init__(**kwargs)


class Chunk(SupabaseModel):
    """Individual chunk of content with metadata"""

    # IDs
    source_id: UUID = Field(..., description="UUID of the source this chunk belongs to")
    chunk_id: UUID = Field(default_factory=uuid4, description="Unique identifier for the chunk")
    document_id: UUID = Field(..., description="UUID of the document this chunk belongs to")

    # Main content
    headers: dict[str, Any] = Field(..., description="Chunk headers")
    text: str = Field(..., description="Chunk text")

    # Metadata
    token_count: int = Field(..., description="Total number of tokens in the document")
    source_url: str = Field(..., description="Source URL of the document")
    page_title: str = Field(..., description="Page title of the document")
