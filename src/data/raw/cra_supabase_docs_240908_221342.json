{
  "input_url": "https://supabase.com/docs/guides/ai",
  "data": [
    {
      "markdown": "AI & Vectors\n\n# Going to Production\n\n## Going to production checklist for AI applications.\n\n* * *\n\nThis guide will help you to prepare your application for production. We'll provide actionable steps to help you scale your application, ensure that it is reliable, can handle the load, and provide optimal accuracy for your use case.\n\nSee our [Engineering for Scale](/docs/guides/ai/engineering-for-scale) guide for more information about engineering at scale.\n\n## Do you need indexes? [\\#](\\#do-you-need-indexes)\n\nSequential scans will result in significantly higher latencies and lower throughput, guaranteeing 100% accuracy and not being RAM bound.\n\nThere are a couple of cases where you might not need indexes:\n\n- You have a small dataset and don't need to scale it.\n- You are not expecting high amounts of vector search queries per second.\n- You need to guarantee 100% accuracy.\n\nYou don't have to create indexes in these cases and can use sequential scans instead. This type of workload will not be RAM bound and will not require any additional resources but will result in higher latencies and lower throughput. Extra CPU cores may help to improve queries per second, but it will not help to improve latency.\n\nOn the other hand, if you need to scale your application, you will need to [create indexes](/docs/guides/ai/vector-indexes). This will result in lower latencies and higher throughput, but will require additional RAM to make use of Postgres Caching. Also, using indexes will result in lower accuracy, since you are replacing exact (KNN) search with approximate (ANN) search.\n\n## HNSW vs IVFFlat indexes [\\#](\\#hnsw-vs-ivfflat-indexes)\n\n`pgvector` supports two types of indexes: HNSW and IVFFlat. We recommend using [HNSW](/docs/guides/ai/vector-indexes/hnsw-indexes) because of its [performance](https://supabase.com/blog/increase-performance-pgvector-hnsw#hnsw-performance-1536-dimensions) and [robustness against changing data](/docs/guides/ai/vector-indexes/hnsw-indexes#when-should-you-create-hnsw-indexes).\n\n## HNSW, understanding `ef_construction`, `ef_search`, and `m` [\\#](\\#hnsw-understanding-efconstruction--efsearch--and-m)\n\nIndex build parameters:\n\n- `m` is the number of bi-directional links created for every new element during construction. Higher `m` is suitable for datasets with high dimensionality and/or high accuracy requirements. Reasonable values for `m` are between 2 and 100. Range 12-48 is a good starting point for most use cases (16 is the default value).\n\n- `ef_construction` is the size of the dynamic list for the nearest neighbors (used during the construction algorithm). Higher `ef_construction` will result in better index quality and higher accuracy, but it will also increase the time required to build the index. `ef_construction` has to be at least 2 \\* `m` (64 is the default value). At some point, increasing `ef_construction` does not improve the quality of the index. You can measure accuracy when `ef_search` = `ef_construction`: if accuracy is lower than 0.9, then there is room for improvement.\n\n\nSearch parameters:\n\n- `ef_search` is the size of the dynamic list for the nearest neighbors (used during the search). Increasing `ef_search` will result in better accuracy, but it will also increase the time required to execute a query (40 is the default value).\n\n## IVFFlat, understanding `probes` and `lists` [\\#](\\#ivfflat-understanding-probes-and-lists)\n\nIndexes used for approximate vector similarity search in pgvector divides a dataset into partitions. The number of these partitions is defined by the `lists` constant. The `probes` controls how many lists are going to be searched during a query.\n\nThe values of lists and probes directly affect accuracy and queries per second (QPS).\n\n- Higher `lists` means an index will be built slower, but you can achieve better QPS and accuracy.\n- Higher `probes` means that select queries will be slower, but you can achieve better accuracy.\n- `lists` and `probes` are not independent. Higher `lists` means that you will have to use higher `probes` to achieve the same accuracy.\n\nYou can find more examples of how `lists` and `probes` constants affect accuracy and QPS in [pgvector 0.4.0 performance](https://supabase.com/blog/pgvector-performance) blogpost.\n\n## Performance tips when using indexes [\\#](\\#performance-tips-when-using-indexes)\n\nFirst, a few generic tips which you can pick and choose from:\n\n1. The Supabase managed platform will automatically optimize Postgres configs for you based on your compute addon. But if you self-host, consider **adjusting your Postgres config** based on RAM & CPU cores. See [example optimizations](https://gist.github.com/egor-romanov/323e2847851bbd758081511785573c08) for more details.\n2. Prefer `inner-product` to `L2` or `Cosine` distances if your vectors are normalized (like `text-embedding-ada-002`). If embeddings are not normalized, `Cosine` distance should give the best results with an index.\n3. **Pre-warm your database.** Implement the warm-up technique before transitioning to production or running benchmarks.\n   - Use [pg\\_prewarm](https://www.postgresql.org/docs/current/pgprewarm.html) to load the index into RAM `select pg_prewarm('vecs.docs_vec_idx');`. This will help to avoid cold cache issues.\n   - Execute 10,000 to 50,000 \"warm-up\" queries before each benchmark/prod. This will help to utilize cache and buffers more efficiently.\n4. **Establish your workload.** Finetune `m` and `ef_construction` or `lists` constants for the pgvector index to accelerate your queries (at the expense of a slower build times). For instance, for benchmarks with 1,000,000 OpenAI embeddings, we set `m` and `ef_construction` to 32 and 80, and it resulted in 35% higher QPS than 24 and 56 values respectively.\n5. **Benchmark your own specific workloads.** Doing this during cache warm-up helps gauge the best value for the index build parameters, balancing accuracy with queries per second (QPS).\n\n## Going into production [\\#](\\#going-into-production)\n\n1. Decide if you are going to use indexes or not. You can skip the rest of this guide if you do not use indexes.\n2. Over-provision RAM during preparation. You can scale down in step `5`, but it's better to start with a larger size to get the best results for RAM requirements. (We'd recommend at least 8XL if you're using Supabase.)\n3. Upload your data to the database. If you use the [`vecs`](/docs/guides/ai/python/api) library, it will automatically generate an index with default parameters.\n4. Run a benchmark using randomly generated queries and observe the results. Again, you can use the `vecs` library with the `ann-benchmarks` tool. Do it with default values for index build parameters, you can later adjust them to get the best results.\n5. Monitor the RAM usage, and save it as a note for yourself. You would likely want to use a compute add-on in the future that has the same amount of RAM that was used at the moment (both actual RAM usage and RAM used for cache and buffers).\n6. Scale down your compute add-on to the one that would have the same amount of RAM used at the moment.\n7. Repeat step 3 to load the data into RAM. You should see QPS increase on subsequent runs, and stop when it no longer increases.\n8. Run a benchmark using real queries and observe the results. You can use the `vecs` library for that as well with `ann-benchmarks` tool. Tweak `ef_search` for HNSW or `probes` for IVFFlat until you see that both accuracy and QPS match your requirements.\n9. If you want higher QPS you can increase `m` and `ef_construction` for HNSW or `lists` for IVFFlat parameters (consider switching from IVF to HNSW). You have to rebuild the index with a higher `m` and `ef_construction` values and repeat steps 6-7 to find the best combination of `m`, `ef_construction` and `ef_search` constants to achieve the best QPS and accuracy values. Higher `m`, `ef_construction` mean that index will build slower, but you can achieve better QPS and accuracy. Higher `ef_search` mean that select queries will be slower, but you can achieve better accuracy.\n\n## Useful links [\\#](\\#useful-links)\n\nDon't forget to check out the general [Production Checklist](/docs/guides/platform/going-into-prod) to ensure your project is secure, performant, and will remain available for your users.\n\nYou can look at our [Choosing Compute Add-on](/docs/guides/ai/choosing-compute-addon) guide to get a basic understanding of how much compute you might need for your workload.\n\nOr take a look at our [pgvector 0.5.0 performance](https://supabase.com/blog/increase-performance-pgvector-hnsw) and [pgvector 0.4.0 performance](https://supabase.com/blog/pgvector-performance) blog posts to see what pgvector is capable of and how the above technique can be used to achieve the best results.",
      "metadata": {
        "ogUrl": "https://supabase.com/docs/guides/ai/going-to-prod",
        "title": "Going to Production | Supabase Docs",
        "robots": "index, follow",
        "ogImage": "https://obuldanrptloktxcffvn.supabase.co/functions/v1/og-images?site=docs&type=ai&title=Going%20to%20Production&description=Checklist%20for%20going%20to%20production%20with%20your%20AI%20application.",
        "ogTitle": "Going to Production | Supabase Docs",
        "language": "en",
        "sourceURL": "https://supabase.com/docs/guides/ai/going-to-prod",
        "description": "Checklist for going to production with your AI application.",
        "modifiedTime": "2024-09-06T19:20:40.301Z",
        "ogDescription": "Checklist for going to production with your AI application.",
        "publishedTime": "2024-09-06T19:20:40.300Z",
        "ogLocaleAlternate": [],
        "statusCode": 200
      }
    },
    {
      "markdown": "AI & Vectors\n\n# Concepts\n\n* * *\n\nEmbeddings are core to many AI and vector applications. This guide covers these concepts. If you prefer to get started right away, see our guide on [Generating Embeddings](/docs/guides/ai/quickstarts/generate-text-embeddings).\n\n## What are embeddings? [\\#](\\#what-are-embeddings)\n\nEmbeddings capture the \"relatedness\" of text, images, video, or other types of information. This relatedness is most commonly used for:\n\n- **Search:** how similar is a search term to a body of text?\n- **Recommendations:** how similar are two products?\n- **Classifications:** how do we categorize a body of text?\n- **Clustering:** how do we identify trends?\n\nLet's explore an example of text embeddings. Say we have three phrases:\n\n1. \"The cat chases the mouse\"\n2. \"The kitten hunts rodents\"\n3. \"I like ham sandwiches\"\n\nYour job is to group phrases with similar meaning. If you are a human, this should be obvious. Phrases 1 and 2 are almost identical, while phrase 3 has a completely different meaning.\n\nAlthough phrases 1 and 2 are similar, they share no common vocabulary (besides \"the\"). Yet their meanings are nearly identical. How can we teach a computer that these are the same?\n\n## Human language [\\#](\\#human-language)\n\nHumans use words and symbols to communicate language. But words in isolation are mostly meaningless - we need to draw from shared knowledge & experience in order to make sense of them. The phrase \u201cYou should Google it\u201d only makes sense if you know that Google is a search engine and that people have been using it as a verb.\n\nIn the same way, we need to train a neural network model to understand human language. An effective model should be trained on millions of different examples to understand what each word, phrase, sentence, or paragraph could mean in different contexts.\n\nSo how does this relate to embeddings?\n\n## How do embeddings work? [\\#](\\#how-do-embeddings-work)\n\nEmbeddings compress discrete information (words & symbols) into distributed continuous-valued data (vectors). If we took our phrases from before and plot them on a chart, it might look something like this:\n\n![Vector similarity](https://supabase.com/docs/img/ai/vector-similarity.png)\n\nPhrases 1 and 2 would be plotted close to each other, since their meanings are similar. We would expect phrase 3 to live somewhere far away since it isn't related. If we had a fourth phrase, \u201cSally ate Swiss cheese\u201d, this might exist somewhere between phrase 3 (cheese can go on sandwiches) and phrase 1 (mice like Swiss cheese).\n\nIn this example we only have 2 dimensions: the X and Y axis. In reality, we would need many more dimensions to effectively capture the complexities of human language.\n\n## Using embeddings [\\#](\\#using-embeddings)\n\nCompared to our 2-dimensional example above, most embedding models will output many more dimensions. For example the open source [`gte-small`](https://huggingface.co/Supabase/gte-small) model outputs 384 dimensions.\n\nWhy is this useful? Once we have generated embeddings on multiple texts, it is trivial to calculate how similar they are using vector math operations like cosine distance. A common use case for this is search. Your process might look something like this:\n\n1. Pre-process your knowledge base and generate embeddings for each page\n2. Store your embeddings to be referenced later\n3. Build a search page that prompts your user for input\n4. Take user's input, generate a one-time embedding, then perform a similarity search against your pre-processed embeddings.\n5. Return the most similar pages to the user\n\n## See also [\\#](\\#see-also)\n\n- [Structured and Unstructured embeddings](/docs/guides/ai/structured-unstructured)\n\n### Is this helpful?\n\nYesNo\n\nThanks for your feedback!\n\nOn this page\n\n- [What are embeddings?](#what-are-embeddings)\n- [Human language](#human-language)\n- [How do embeddings work?](#how-do-embeddings-work)\n- [Using embeddings](#using-embeddings)\n- [See also](#see-also)\n\n1. We only collect analytics essential to ensuring smooth operation of our services. [Learn more](https://supabase.com/privacy)\n\n\n\n\n\n   AcceptOpt out[Learn more](https://supabase.com/privacy)",
      "metadata": {
        "ogUrl": "https://supabase.com/docs/guides/ai/concepts",
        "title": "Concepts | Supabase Docs",
        "robots": "index, follow",
        "ogImage": "https://obuldanrptloktxcffvn.supabase.co/functions/v1/og-images?site=docs&type=ai&title=Concepts&description=Learn%20about%20embeddings%20within%20AI%20and%20vector%20applications.",
        "ogTitle": "Concepts | Supabase Docs",
        "language": "en",
        "sourceURL": "https://supabase.com/docs/guides/ai/concepts",
        "description": "Learn about embeddings within AI and vector applications.",
        "modifiedTime": "2024-09-06T19:20:41.221Z",
        "ogDescription": "Learn about embeddings within AI and vector applications.",
        "publishedTime": "2024-09-06T19:20:41.221Z",
        "ogLocaleAlternate": [],
        "statusCode": 200
      }
    },
    {
      "markdown": "AI & Vectors\n\n# AI & Vectors\n\n## The best vector database is the database you already have.\n\n* * *\n\nSupabase provides an open source toolkit for developing AI applications using Postgres and pgvector. Use the Supabase client libraries to store, index, and query your vector embeddings at scale.\n\nThe toolkit includes:\n\n- A [vector store](/docs/guides/ai/vector-columns) and embeddings support using Postgres and pgvector.\n- A [Python client](/docs/guides/ai/vecs-python-client) for managing unstructured embeddings.\n- An [embedding generation](/docs/guides/ai/quickstarts/generate-text-embeddings) process using open source models directly in Edge Functions.\n- [Database migrations](/docs/guides/ai/examples/headless-vector-search#prepare-your-database) for managing structured embeddings.\n- Integrations with all popular AI providers, such as [OpenAI](/docs/guides/ai/examples/openai), [Hugging Face](/docs/guides/ai/hugging-face), [LangChain](/docs/guides/ai/langchain), and more.\n\nYou can use Supabase to build different types of search features for your app, including:\n\n- [Semantic search](/docs/guides/ai/semantic-search): search by meaning rather than exact keywords\n- [Keyword search](/docs/guides/ai/keyword-search): search by words or phrases\n- [Hybrid search](/docs/guides/ai/hybrid-search): combine semantic search with keyword search\n\n## Examples [\\#](\\#examples)\n\nCheck out all of the AI [templates and examples](https://github.com/supabase/supabase/tree/master/examples/ai) in our GitHub repository.\n\n[![Headless Vector Search](https://supabase.com/docs/img/icons/github-icon-light.svg)\\\\\n\\\\\nHeadless Vector Search\\\\\n\\\\\nA toolkit to perform vector similarity search on your knowledge base embeddings.](/docs/guides/ai/examples/headless-vector-search)\n\n[![Image Search with OpenAI CLIP](https://supabase.com/docs/img/icons/github-icon-light.svg)\\\\\n\\\\\nImage Search with OpenAI CLIP\\\\\n\\\\\nImplement image search with the OpenAI CLIP Model and Supabase Vector.](/docs/guides/ai/examples/image-search-openai-clip)\n\n[![Hugging Face inference](https://supabase.com/docs/img/icons/github-icon-light.svg)\\\\\n\\\\\nHugging Face inference\\\\\n\\\\\nGenerate image captions using Hugging Face.](/docs/guides/ai/examples/huggingface-image-captioning)\n\n[![OpenAI completions](https://supabase.com/docs/img/icons/github-icon-light.svg)\\\\\n\\\\\nOpenAI completions\\\\\n\\\\\nGenerate GPT text completions using OpenAI in Edge Functions.](/docs/guides/ai/examples/openai)\n\n[![Building ChatGPT Plugins](https://supabase.com/docs/img/icons/github-icon-light.svg)\\\\\n\\\\\nBuilding ChatGPT Plugins\\\\\n\\\\\nUse Supabase as a Retrieval Store for your ChatGPT plugin.](/docs/guides/ai/examples/building-chatgpt-plugins)\n\n[![Vector search with Next.js and OpenAI](https://supabase.com/docs/img/icons/github-icon-light.svg)\\\\\n\\\\\nVector search with Next.js and OpenAI\\\\\n\\\\\nLearn how to build a ChatGPT-style doc search powered by Next.js, OpenAI, and Supabase.](/docs/guides/ai/examples/nextjs-vector-search)\n\n## Integrations [\\#](\\#integrations)\n\n[OpenAI\\\\\n\\\\\nOpenAI is an AI research and deployment company. Supabase provides a simple way to use OpenAI in your applications.](/docs/guides/ai/examples/building-chatgpt-plugins)\n\n[Amazon Bedrock\\\\\n\\\\\nA fully managed service that offers a choice of high-performing foundation models from leading AI companies.](/docs/guides/ai/integrations/amazon-bedrock)\n\n[Hugging Face\\\\\n\\\\\nHugging Face is an open-source provider of NLP technologies. Supabase provides a simple way to use Hugging Face's models in your applications.](/docs/guides/ai/hugging-face)\n\n[LangChain\\\\\n\\\\\nLangChain is a language-agnostic, open-source, and self-hosted API for text translation, summarization, and sentiment analysis.](/docs/guides/ai/langchain)\n\n[LlamaIndex\\\\\n\\\\\nLlamaIndex is a data framework for your LLM applications.](/docs/guides/ai/integrations/llamaindex)\n\n## Case studies [\\#](\\#case-studies)\n\n[Berri AI Boosts Productivity by Migrating from AWS RDS to Supabase with pgvector\\\\\n\\\\\nLearn how Berri AI overcame challenges with self-hosting their vector database on AWS RDS and successfully migrated to Supabase.](https://supabase.com/customers/berriai)\n\n[Mendable switches from Pinecone to Supabase for PostgreSQL vector embeddings\\\\\n\\\\\nHow Mendable boosts efficiency and accuracy of chat powered search for documentation using Supabase with pgvector](https://supabase.com/customers/mendableai)\n\n[Markprompt: GDPR-Compliant AI Chatbots for Docs and Websites\\\\\n\\\\\nAI-powered chatbot platform, Markprompt, empowers developers to deliver efficient and GDPR-compliant prompt experiences on top of their content, by leveraging Supabase's secure and privacy-focused database and authentication solutions](https://supabase.com/customers/markprompt)",
      "metadata": {
        "ogUrl": "https://supabase.com/docs/guides/ai",
        "title": "AI & Vectors | Supabase Docs",
        "robots": "index, follow",
        "ogImage": "https://obuldanrptloktxcffvn.supabase.co/functions/v1/og-images?site=docs&type=ai&title=AI%20%26%20Vectors&description=The%20best%20vector%20database%20is%20the%20database%20you%20already%20have.",
        "ogTitle": "AI & Vectors | Supabase Docs",
        "language": "en",
        "sourceURL": "https://supabase.com/docs/guides/ai",
        "description": "The best vector database is the database you already have.",
        "modifiedTime": "2024-09-06T19:20:40.301Z",
        "ogDescription": "The best vector database is the database you already have.",
        "publishedTime": "2024-09-06T19:20:40.300Z",
        "ogLocaleAlternate": [],
        "statusCode": 200
      }
    },
    {
      "markdown": "AI & Vectors\n\n# Choosing your Compute Add-on\n\n## Choosing the right Compute Add-on for your vector workload.\n\n* * *\n\nYou have two options for scaling your vector workload:\n\n1. Increase the size of your database. This guide will help you choose the right size for your workload.\n2. Spread your workload across multiple databases. You can find more details about this approach in [Engineering for Scale](engineering-for-scale).\n\n## Dimensionality [\\#](\\#dimensionality)\n\nThe number of dimensions in your embeddings is the most important factor in choosing the right Compute Add-on. In general, the lower the dimensionality the better the performance. We've provided guidance for some of the more common embedding dimensions below. For each benchmark, we used [Vecs](https://github.com/supabase/vecs) to create a collection, upload the embeddings to a single table, and create both the `IVFFlat` and `HNSW` indexes for `inner-product` distance measure for the embedding column. We then ran a series of queries to measure the performance of different compute add-ons:\n\n## HNSW [\\#](\\#hnsw)\n\n### 384 dimensions [\\#](\\#hnsw-384-dimensions)\n\nThis benchmark uses the dbpedia-entities-openai-1M dataset containing 1,000,000 embeddings of text, regenerated for 384 dimension embeddings. Each embedding is generated using [gte-small](https://huggingface.co/Supabase/gte-small).\n\ngte-small-384\n\n| Compute Size | Vectors | m | ef\\_construction | ef\\_search | QPS | Latency Mean | Latency p95 | RAM Usage | RAM |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Micro | 100,000 | 16 | 64 | 60 | 580 | 0.017 sec | 0.024 sec | 1.2 (Swap) | 1 GB |\n| Small | 250,000 | 24 | 64 | 60 | 440 | 0.022 sec | 0.033 sec | 2 GB | 2 GB |\n| Medium | 500,000 | 24 | 64 | 80 | 350 | 0.028 sec | 0.045 sec | 4 GB | 4 GB |\n| Large | 1,000,000 | 32 | 80 | 100 | 270 | 0.073 sec | 0.108 sec | 7 GB | 8 GB |\n| XL | 1,000,000 | 32 | 80 | 100 | 525 | 0.038 sec | 0.059 sec | 9 GB | 16 GB |\n| 2XL | 1,000,000 | 32 | 80 | 100 | 790 | 0.025 sec | 0.037 sec | 9 GB | 32 GB |\n| 4XL | 1,000,000 | 32 | 80 | 100 | 1650 | 0.015 sec | 0.018 sec | 11 GB | 64 GB |\n| 8XL | 1,000,000 | 32 | 80 | 100 | 2690 | 0.015 sec | 0.016 sec | 13 GB | 128 GB |\n| 12XL | 1,000,000 | 32 | 80 | 100 | 3900 | 0.014 sec | 0.016 sec | 13 GB | 192 GB |\n| 16XL | 1,000,000 | 32 | 80 | 100 | 4200 | 0.014 sec | 0.016 sec | 20 GB | 256 GB |\n\nAccuracy was 0.99 for benchmarks.\n\n### 960 dimensions [\\#](\\#hnsw-960-dimensions)\n\nThis benchmark uses the [gist-960](http://corpus-texmex.irisa.fr/) dataset, which contains 1,000,000 embeddings of images. Each embedding is 960 dimensions.\n\ngist-960\n\n| Compute Size | Vectors | m | ef\\_construction | ef\\_search | QPS | Latency Mean | Latency p95 | RAM Usage | RAM |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Micro | 30,000 | 16 | 64 | 65 | 430 | 0.024 sec | 0.034 sec | 1.2 GB (Swap) | 1 GB |\n| Small | 100,000 | 32 | 80 | 60 | 260 | 0.040 sec | 0.054 sec | 2.2 GB (Swap) | 2 GB |\n| Medium | 250,000 | 32 | 80 | 90 | 120 | 0.083 sec | 0.106 sec | 4 GB | 4 GB |\n| Large | 500,000 | 32 | 80 | 120 | 160 | 0.063 sec | 0.087 sec | 7 GB | 8 GB |\n| XL | 1,000,000 | 32 | 80 | 200 | 200 | 0.049 sec | 0.072 sec | 13 GB | 16 GB |\n| 2XL | 1,000,000 | 32 | 80 | 200 | 340 | 0.025 sec | 0.029 sec | 17 GB | 32 GB |\n| 4XL | 1,000,000 | 32 | 80 | 200 | 630 | 0.031 sec | 0.050 sec | 18 GB | 64 GB |\n| 8XL | 1,000,000 | 32 | 80 | 200 | 1100 | 0.034 sec | 0.048 sec | 19 GB | 128 GB |\n| 12XL | 1,000,000 | 32 | 80 | 200 | 1420 | 0.041 sec | 0.095 sec | 21 GB | 192 GB |\n| 16XL | 1,000,000 | 32 | 80 | 200 | 1650 | 0.037 sec | 0.081 sec | 23 GB | 256 GB |\n\nAccuracy was 0.99 for benchmarks.\n\nQPS can also be improved by increasing [`m` and `ef_construction`](/docs/guides/ai/going-to-prod#hnsw-understanding-efconstruction--efsearch--and-m). This will allow you to use a smaller value for `ef_search` and increase QPS.\n\n### 1536 dimensions [\\#](\\#hnsw-1536-dimensions)\n\nThis benchmark uses the [dbpedia-entities-openai-1M](https://huggingface.co/datasets/KShivendu/dbpedia-entities-openai-1M) dataset, which contains 1,000,000 embeddings of text. And 224,482 embeddings from [Wikipedia articles](https://huggingface.co/datasets/Supabase/wikipedia-en-embeddings) for compute add-ons `large` and below. Each embedding is 1536 dimensions created with the [OpenAI Embeddings API](https://platform.openai.com/docs/guides/embeddings).\n\nOpenAI-1536\n\n| Compute Size | Vectors | m | ef\\_construction | ef\\_search | QPS | Latency Mean | Latency p95 | RAM Usage | RAM |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Micro | 15,000 | 16 | 40 | 40 | 480 | 0.011 sec | 0.016 sec | 1.2 GB (Swap) | 1 GB |\n| Small | 50,000 | 32 | 64 | 100 | 175 | 0.031 sec | 0.051 sec | 2.2 GB (Swap) | 2 GB |\n| Medium | 100,000 | 32 | 64 | 100 | 240 | 0.083 sec | 0.126 sec | 4 GB | 4 GB |\n| Large | 224,482 | 32 | 64 | 100 | 280 | 0.017 sec | 0.028 sec | 8 GB | 8 GB |\n| XL | 500,000 | 24 | 56 | 100 | 360 | 0.055 sec | 0.135 sec | 13 GB | 16 GB |\n| 2XL | 1,000,000 | 24 | 56 | 250 | 560 | 0.036 sec | 0.058 sec | 32 GB | 32 GB |\n| 4XL | 1,000,000 | 24 | 56 | 250 | 950 | 0.021 sec | 0.033 sec | 39 GB | 64 GB |\n| 8XL | 1,000,000 | 24 | 56 | 250 | 1650 | 0.016 sec | 0.023 sec | 40 GB | 128 GB |\n| 12XL | 1,000,000 | 24 | 56 | 250 | 1900 | 0.015 sec | 0.021 sec | 38 GB | 192 GB |\n| 16XL | 1,000,000 | 24 | 56 | 250 | 2200 | 0.015 sec | 0.020 sec | 40 GB | 256 GB |\n\nAccuracy was 0.99 for benchmarks.\n\nQPS can also be improved by increasing [`m` and `ef_construction`](/docs/guides/ai/going-to-prod#hnsw-understanding-efconstruction--efsearch--and-m). This will allow you to use a smaller value for `ef_search` and increase QPS. For example, increasing `m` to 32 and `ef_construction` to 80 for 4XL will increase QPS to 1280.\n\nIt is possible to upload more vectors to a single table if Memory allows it (for example, 4XL plan and higher for OpenAI embeddings). But it will affect the performance of the queries: QPS will be lower, and latency will be higher. Scaling should be almost linear, but it is recommended to benchmark your workload to find the optimal number of vectors per table and per database instance.\n\n## IVFFlat [\\#](\\#ivfflat)\n\n### 384 dimensions [\\#](\\#ivfflat-384-dimensions)\n\nThis benchmark uses the dbpedia-entities-openai-1M dataset containing 1,000,000 embeddings of text, regenerated for 384 dimension embeddings. Each embedding is generated using [gte-small](https://huggingface.co/Supabase/gte-small).\n\ngte-small-384, accuracy=.98gte-small-384, accuracy=.99\n\n| Compute Size | Vectors | Lists | Probes | QPS | Latency Mean | Latency p95 | RAM Usage | RAM |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Micro | 100,000 | 500 | 50 | 205 | 0.048 sec | 0.066 sec | 1.2 GB (Swap) | 1 GB |\n| Small | 250,000 | 1000 | 60 | 160 | 0.062 sec | 0.079 sec | 2 GB | 2 GB |\n| Medium | 500,000 | 2000 | 80 | 120 | 0.082 sec | 0.104 sec | 3.2 GB | 4 GB |\n| Large | 1,000,000 | 5000 | 150 | 75 | 0.269 sec | 0.375 sec | 6.5 GB | 8 GB |\n| XL | 1,000,000 | 5000 | 150 | 150 | 0.131 sec | 0.178 sec | 9 GB | 16 GB |\n| 2XL | 1,000,000 | 5000 | 150 | 300 | 0.066 sec | 0.099 sec | 10 GB | 32 GB |\n| 4XL | 1,000,000 | 5000 | 150 | 570 | 0.035 sec | 0.046 sec | 10 GB | 64 GB |\n| 8XL | 1,000,000 | 5000 | 150 | 1400 | 0.023 sec | 0.028 sec | 12 GB | 128 GB |\n| 12XL | 1,000,000 | 5000 | 150 | 1550 | 0.030 sec | 0.039 sec | 12 GB | 192 GB |\n| 16XL | 1,000,000 | 5000 | 150 | 1800 | 0.030 sec | 0.039 sec | 16 GB | 256 GB |\n\n### 960 dimensions [\\#](\\#ivfflat-960-dimensions)\n\nThis benchmark uses the [gist-960](http://corpus-texmex.irisa.fr/) dataset, which contains 1,000,000 embeddings of images. Each embedding is 960 dimensions.\n\ngist-960, probes = 10\n\n| Compute Size | Vectors | Lists | QPS | Latency Mean | Latency p95 | RAM Usage | RAM |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Micro | 30,000 | 30 | 75 | 0.065 sec | 0.088 sec | 1.1 GB (Swap) | 1 GB |\n| Small | 100,000 | 100 | 78 | 0.064 sec | 0.092 sec | 1.8 GB | 2 GB |\n| Medium | 250,000 | 250 | 58 | 0.085 sec | 0.129 sec | 3.2 GB | 4 GB |\n| Large | 500,000 | 500 | 55 | 0.088 sec | 0.140 sec | 5 GB | 8 GB |\n| XL | 1,000,000 | 1000 | 110 | 0.046 sec | 0.070 sec | 14 GB | 16 GB |\n| 2XL | 1,000,000 | 1000 | 235 | 0.083 sec | 0.136 sec | 10 GB | 32 GB |\n| 4XL | 1,000,000 | 1000 | 420 | 0.071 sec | 0.106 sec | 11 GB | 64 GB |\n| 8XL | 1,000,000 | 1000 | 815 | 0.072 sec | 0.106 sec | 13 GB | 128 GB |\n| 12XL | 1,000,000 | 1000 | 1150 | 0.052 sec | 0.078 sec | 15.5 GB | 192 GB |\n| 16XL | 1,000,000 | 1000 | 1345 | 0.072 sec | 0.106 sec | 17.5 GB | 256 GB |\n\n### 1536 dimensions [\\#](\\#ivfflat-1536-dimensions)\n\nThis benchmark uses the [dbpedia-entities-openai-1M](https://huggingface.co/datasets/KShivendu/dbpedia-entities-openai-1M) dataset, which contains 1,000,000 embeddings of text. Each embedding is 1536 dimensions created with the [OpenAI Embeddings API](https://platform.openai.com/docs/guides/embeddings).\n\nOpenAI-1536, probes = 10OpenAI-1536, probes = 40\n\n| Compute Size | Vectors | Lists | QPS | Latency Mean | Latency p95 | RAM Usage | RAM |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Micro | 20,000 | 40 | 135 | 0.372 sec | 0.412 sec | 1.2 GB (Swap) | 1 GB |\n| Small | 50,000 | 100 | 140 | 0.357 sec | 0.398 sec | 1.8 GB | 2 GB |\n| Medium | 100,000 | 200 | 130 | 0.383 sec | 0.446 sec | 3.7 GB | 4 GB |\n| Large | 250,000 | 500 | 130 | 0.378 sec | 0.434 sec | 7 GB | 8 GB |\n| XL | 500,000 | 1000 | 235 | 0.213 sec | 0.271 sec | 13.5 GB | 16 GB |\n| 2XL | 1,000,000 | 2000 | 380 | 0.133 sec | 0.236 sec | 30 GB | 32 GB |\n| 4XL | 1,000,000 | 2000 | 720 | 0.068 sec | 0.120 sec | 35 GB | 64 GB |\n| 8XL | 1,000,000 | 2000 | 1250 | 0.039 sec | 0.066 sec | 38 GB | 128 GB |\n| 12XL | 1,000,000 | 2000 | 1600 | 0.030 sec | 0.052 sec | 41 GB | 192 GB |\n| 16XL | 1,000,000 | 2000 | 1790 | 0.029 sec | 0.051 sec | 45 GB | 256 GB |\n\nFor 1,000,000 vectors 10 probes results to accuracy of 0.91. And for 500,000 vectors and below 10 probes results to accuracy in the range of 0.95 - 0.99. To increase accuracy, you need to increase the number of probes.\n\nIt is possible to upload more vectors to a single table if Memory allows it (for example, 4XL plan and higher for OpenAI embeddings). But it will affect the performance of the queries: QPS will be lower, and latency will be higher. Scaling should be almost linear, but it is recommended to benchmark your workload to find the optimal number of vectors per table and per database instance.\n\n## Performance tips [\\#](\\#performance-tips)\n\nThere are various ways to improve your pgvector performance. Here are some tips:\n\n### Pre-warming your database [\\#](\\#pre-warming-your-database)\n\nIt's useful to execute a few thousand \u201cwarm-up\u201d queries before going into production. This helps help with RAM utilization. This can also help to determine that you've selected the right compute size for your workload.\n\n### Finetune index parameters [\\#](\\#finetune-index-parameters)\n\nYou can increase the Requests per Second by increasing `m` and `ef_construction` or `lists`. This also has an important caveat: building the index takes longer with higher values for these parameters.\n\nHNSWIVFFlat\n\nCheck out more tips and the complete step-by-step guide in [Going to Production for AI applications](going-to-prod).\n\n## Benchmark methodology [\\#](\\#benchmark-methodology)\n\nWe follow techniques outlined in the [ANN Benchmarks](https://github.com/erikbern/ann-benchmarks) methodology. A Python test runner is responsible for uploading the data, creating the index, and running the queries. The pgvector engine is implemented using [vecs](https://github.com/supabase/vecs), a Python client for pgvector.\n\nEach test is run for a minimum of 30-40 minutes. They include a series of experiments executed at different concurrency levels to measure the engine's performance under different load types. The results are then averaged.\n\nAs a general recommendation, we suggest using a concurrency level of 5 or more for most workloads and 30 or more for high-load workloads.",
      "metadata": {
        "ogUrl": "https://supabase.com/docs/guides/ai/choosing-compute-addon",
        "title": "Choosing your Compute Add-on | Supabase Docs",
        "robots": "index, follow",
        "ogImage": "https://obuldanrptloktxcffvn.supabase.co/functions/v1/og-images?site=docs&type=ai&title=Choosing%20your%20Compute%20Add-on&description=Choosing%20the%20right%20Compute%20Add-on%20for%20your%20vector%20workload.",
        "ogTitle": "Choosing your Compute Add-on | Supabase Docs",
        "language": "en",
        "sourceURL": "https://supabase.com/docs/guides/ai/choosing-compute-addon",
        "description": "Choosing the right Compute Add-on for your vector workload.",
        "modifiedTime": "2024-09-06T19:20:40.301Z",
        "ogDescription": "Choosing the right Compute Add-on for your vector workload.",
        "publishedTime": "2024-09-06T19:20:40.300Z",
        "ogLocaleAlternate": [],
        "statusCode": 200
      }
    },
    {
      "markdown": "AI & Vectors\n\n# Engineering for Scale\n\n## Building an enterprise-grade vector architecture.\n\n* * *\n\nContent sources for vectors can be extremely large. As you grow you should run your Vector workloads across several secondary databases (sometimes called \"pods\"), which allows each collection to scale independently.\n\n## Simple workloads [\\#](\\#simple-workloads)\n\nFor small workloads, it's typical to store your data in a single database.\n\nIf you've used [Vecs](/docs/guides/ai/vecs-python-client) to create 3 different collections, you can expose collections to your web or mobile application using [views](/docs/guides/database/tables#views):\n\n![single database](https://supabase.com/docs/_next/image?url=%2Fdocs%2Fimg%2Fai%2Fscaling%2Fengineering-for-scale--single-database--light.png&w=3840&q=75&dpl=dpl_GiCDf4oknfdUcgmXNidH7itZWLva)\n\nFor example, with 3 collections, called `docs`, `posts`, and `images`, we could expose the \"docs\" inside the public schema like this:\n\n`\n1\ncreate view public.docs as\n2\nselect\n3\nid,\n4\nembedding,\n5\nmetadata, # Expose the metadata as JSON\n6\n(metadata->>'url')::text as url # Extract the URL as a string\n7\nfrom vector\n`\n\nYou can then use any of the client libraries to access your collections within your applications:\n\n`\n1\nconst { data, error } = await supabase\n2\n.from('docs')\n3\n.select('id, embedding, metadata')\n4\n.eq('url', '/hello-world')\n`\n\n## Enterprise workloads [\\#](\\#enterprise-workloads)\n\nAs you move into production, we recommend splitting your collections into separate projects. This is because it allows your vector stores to scale independently of your production data. Vectors typically grow faster than operational data, and they have different resource requirements. Running them on separate databases removes the single-point-of-failure.\n\n![With secondaries](https://supabase.com/docs/_next/image?url=%2Fdocs%2Fimg%2Fai%2Fscaling%2Fengineering-for-scale--with-secondaries--light.png&w=3840&q=75&dpl=dpl_GiCDf4oknfdUcgmXNidH7itZWLva)\n\nYou can use as many secondary databases as you need to manage your collections. With this architecture, you have 2 options for accessing collections within your application:\n\n1. Query the collections directly using Vecs.\n2. Access the collections from your Primary database through a Wrapper.\n\nYou can use both of these in tandem to suit your use-case. We recommend option `1` wherever possible, as it offers the most scalability.\n\n### Query collections using Vecs [\\#](\\#query-collections-using-vecs)\n\nVecs provides methods for querying collections, either using a [cosine similarity function](https://supabase.github.io/vecs/api/#basic) or with [metadata filtering](https://supabase.github.io/vecs/api/#metadata-filtering).\n\n`\n1\n# cosine similarity\n2\ndocs.query(query_vector=[0.4,0.5,0.6], limit=5)\n3\n4\n# metadata filtering\n5\ndocs.query(\n6\n    query_vector=[0.4,0.5,0.6],\n7\n    limit=5,\n8\n    filters={\"year\": {\"$eq\": 2012}}, # metadata filters\n9\n)\n`\n\n### Accessing external collections using Wrappers [\\#](\\#accessing-external-collections-using-wrappers)\n\nSupabase supports [Foreign Data Wrappers](/blog/postgres-foreign-data-wrappers-rust). Wrappers allow you to connect two databases together so that you can query them over the network.\n\nThis involves 2 steps: connecting to your remote database from the primary and creating a Foreign Table.\n\n#### Connecting your remote database [\\#](\\#connecting-your-remote-database)\n\nInside your Primary database we need to provide the credentials to access the secondary database:\n\n`\n1\ncreate extension postgres_fdw;\n2\n3\ncreate server docs_server\n4\nforeign data wrapper postgres_fdw\n5\noptions (host 'db.xxx.supabase.co', port '5432', dbname 'postgres');\n6\n7\ncreate user mapping for docs_user\n8\nserver docs_server\n9\noptions (user 'postgres', password 'password');\n`\n\n#### Create a foreign table [\\#](\\#create-a-foreign-table)\n\nWe can now create a foreign table to access the data in our secondary project.\n\n`\n1\ncreate foreign table docs (\n2\nid text not null,\n3\nembedding vector(384),\n4\nmetadata jsonb,\n5\nurl text\n6\n)\n7\nserver docs_server\n8\noptions (schema_name 'public', table_name 'docs');\n`\n\nThis looks very similar to our View example above, and you can continue to use the client libraries to access your collections through the foreign table:\n\n`\n1\nconst { data, error } = await supabase\n2\n.from('docs')\n3\n.select('id, embedding, metadata')\n4\n.eq('url', '/hello-world')\n`\n\n### Enterprise architecture [\\#](\\#enterprise-architecture)\n\nThis diagram provides an example architecture that allows you to access the collections either with our client libraries or using Vecs. You can add as many secondary databases as you need (in this example we only show one):\n\n![multi database](https://supabase.com/docs/_next/image?url=%2Fdocs%2Fimg%2Fai%2Fscaling%2Fengineering-for-scale--multi-database--light.png&w=3840&q=75&dpl=dpl_GiCDf4oknfdUcgmXNidH7itZWLva)\n\n### Is this helpful?\n\nYesNo\n\nThanks for your feedback!\n\nOn this page\n\n- [Simple workloads](#simple-workloads)\n- [Enterprise workloads](#enterprise-workloads)\n- [Query collections using Vecs](#query-collections-using-vecs)\n- [Accessing external collections using Wrappers](#accessing-external-collections-using-wrappers)\n- [Enterprise architecture](#enterprise-architecture)\n\n1. We only collect analytics essential to ensuring smooth operation of our services. [Learn more](https://supabase.com/privacy)\n\n\n\n\n\n   AcceptOpt out[Learn more](https://supabase.com/privacy)",
      "metadata": {
        "ogUrl": "https://supabase.com/docs/guides/ai/engineering-for-scale",
        "title": "Engineering for Scale | Supabase Docs",
        "robots": "index, follow",
        "ogImage": "https://obuldanrptloktxcffvn.supabase.co/functions/v1/og-images?site=docs&type=ai&title=Engineering%20for%20Scale&description=Building%20an%20enterprise-grade%20vector%20architecture",
        "ogTitle": "Engineering for Scale | Supabase Docs",
        "language": "en",
        "sourceURL": "https://supabase.com/docs/guides/ai/engineering-for-scale",
        "description": "Building an enterprise-grade vector architecture",
        "modifiedTime": "2024-09-06T19:20:40.691Z",
        "ogDescription": "Building an enterprise-grade vector architecture",
        "publishedTime": "2024-09-06T19:20:40.691Z",
        "ogLocaleAlternate": [],
        "statusCode": 200
      }
    }
  ]
}